"""
Telegram Notifications Module - User-Friendly Messaging

Provides clear, actionable, and easy-to-understand Telegram notifications
for arbitrage opportunities, errors, reports, and system status.

Usage:
    from telegram_notifications import send_arbitrage_alert, send_bet_placed_alert
    send_arbitrage_alert(arb, stakes, odds, profit)
    send_bet_placed_alert(bet_details, bet_number, total_bets)
"""

import os
import logging
import requests
from typing import Optional, List, Dict, Any
from datetime import datetime

logger = logging.getLogger(__name__)

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")


def decimal_to_american(decimal_odds: float) -> str:
    """Convert decimal odds to American format."""
    if decimal_odds >= 2.0:
        american = (decimal_odds - 1) * 100
        return f"+{int(american)}"
    else:
        american = -100 / (decimal_odds - 1)
        return f"{int(american)}"


def format_readable_time(iso_time: str) -> str:
    """Convert ISO time to human-readable format."""
    try:
        dt = datetime.fromisoformat(iso_time.replace('Z', '+00:00'))
        now = datetime.now(dt.tzinfo)
        diff = dt - now
        
        hours = int(diff.total_seconds() / 3600)
        
        if hours < 0:
            return "LIVE NOW"
        elif hours < 1:
            mins = int(diff.total_seconds() / 60)
            return f"Starts in {mins} minutes"
        elif hours < 24:
            return f"Tonight {dt.strftime('%I:%M %p')} ({hours}h)"
        elif hours < 48:
            return f"Tomorrow {dt.strftime('%I:%M %p')}"
        else:
            return dt.strftime('%b %d, %I:%M %p')
    except:
        return iso_time


def send_telegram_message(message: str, bot_token: str = None, chat_id: str = None, retries: int = 2) -> bool:
    """
    Send text message to Telegram.
    
    Args:
        message: Message text (supports Markdown)
        bot_token: Bot token (uses env var if not provided)
        chat_id: Chat ID (uses env var if not provided)
        retries: Number of retry attempts
        
    Returns:
        True if sent successfully, False otherwise
    """
    token = bot_token or TELEGRAM_BOT_TOKEN
    chat = chat_id or TELEGRAM_CHAT_ID
    
    if not token or not chat:
        logger.warning("Ã¢Å¡ Ã¯Â¸Â Telegram credentials not configured")
        return False
    
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    
    for attempt in range(retries):
        try:
            data = {
                "chat_id": chat,
                "text": message,
                "parse_mode": "HTML",
                "disable_web_page_preview": True
            }
            
            response = requests.post(url, data=data, timeout=10)
            
            if response.status_code == 200:
                logger.info("Ã¢Å“â€¦ Telegram message sent successfully")
                return True
            else:
                logger.error(f"Ã¢ÂÅ’ Telegram API error: {response.text}")
                
        except Exception as e:
            logger.error(f"Ã¢ÂÅ’ Telegram send error (attempt {attempt+1}): {e}")
            
            if attempt == retries - 1:
                logger.warning("Ã¢Å¡ Ã¯Â¸Â Failed to send Telegram message after retries")
    
    return False


def send_telegram_file(file_path: str, caption: str = "", bot_token: str = None, 
                       chat_id: str = None, retries: int = 2) -> bool:
    """
    Send file to Telegram.
    
    Args:
        file_path: Path to file
        caption: File caption
        bot_token: Bot token (uses env var if not provided)
        chat_id: Chat ID (uses env var if not provided)
        retries: Number of retry attempts
        
    Returns:
        True if sent successfully, False otherwise
    """
    token = bot_token or TELEGRAM_BOT_TOKEN
    chat = chat_id or TELEGRAM_CHAT_ID
    
    if not token or not chat:
        return False
    
    if not os.path.isfile(file_path):
        logger.error(f"Ã¢ÂÅ’ File not found: {file_path}")
        return False
    
    url = f"https://api.telegram.org/bot{token}/sendDocument"
    
    for attempt in range(retries):
        try:
            with open(file_path, "rb") as file:
                files = {"document": file}
                data = {"chat_id": chat, "caption": caption}
                
                response = requests.post(url, files=files, data=data, timeout=30)
                
                if response.status_code == 200:
                    logger.info(f"âœ… File sent: {os.path.basename(file_path)}")
                    return True
                else:
                    logger.error(f"âŒ Telegram API error: {response.text}")
                    
        except Exception as e:
            logger.error(f"âŒ File send error (attempt {attempt+1}): {e}")
    
    return False


# === ARBITRAGE ALERTS ===

def send_arbitrage_alert(arb: Dict[str, Any], stakes: List[float], 
                        odds: List[float], profit: float) -> bool:
    """
    Send comprehensive, dummy-proof arbitrage opportunity notification.
    
    Args:
        arb: Arbitrage opportunity details
        stakes: Stake amounts for each bet
        odds: Odds for each outcome
        profit: Expected profit
        
    Returns:
        True if sent successfully
    """
    try:
        outcomes = list(arb.get('outcomes', {}).keys())
        bookmakers_dict = arb.get('bookmakers', {})
        market = arb.get('market', 'Unknown')
        sport = arb.get('sport', 'Unknown').replace('_', ' ').title()
        home_team = arb.get('home_team', 'Team A')
        away_team = arb.get('away_team', 'Team B')
        commence_time = arb.get('commence_time', '')
        
        # Determine profit emoji
        if profit >= 10:
            profit_emoji = "ğŸ’°ğŸ’°"
        elif profit >= 5:
            profit_emoji = "ğŸ’°"
        else:
            profit_emoji = "ğŸ’µ"
        
        # Format time
        readable_time = format_readable_time(commence_time)
        
        # Calculate totals
        total_stake = sum(stakes)
        returns = [stake * odd for stake, odd in zip(stakes, odds)]
        
        # Build message
        message = f"""
{profit_emoji} *ARBITRAGE OPPORTUNITY - ACT NOW!*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ€ {market_display}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸŸï¸ <b>GAME:</b>
{home_team} vs {away_team}
â° <b>Starts:</b> {readable_time}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… <b>GUARANTEED PROFIT: ${profit:.2f}</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“‹ <b>STEP-BY-STEP INSTRUCTIONS:</b>

"""
        
        # Add each bet with detailed instructions
        for i, (outcome, stake, odd) in enumerate(zip(outcomes, stakes, odds), 1):
            bookmaker = bookmakers_dict.get(outcome, 'Unknown').upper()
            american_odds = decimal_to_american(odd)
            potential_return = stake * odd
            
            message += f"""
ğŸ¯ <b>BET #{i} - {outcome}</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ <b>Where:</b> {bookmaker}
ğŸ’µ <b>Bet Amount:</b> ${stake:.2f}
ğŸ“Š <b>Odds:</b> {odd:.2f} ({american_odds})
ğŸ’° <b>Potential Return:</b> ${potential_return:.2f}

ğŸ”¹ <b>HOW TO PLACE:</b>
1. Open {bookmaker} app/website
2. Find: {home_team} vs {away_team}
3. Select: {outcome}
4. Enter stake: ${stake:.2f}
5. Confirm bet

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
        
        # Add profit explanation
        message += f"""
ğŸ’¡ <b>WHY THIS WORKS:</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<b>Total Invested:</b> ${total_stake:.2f}

"""
        
        # Show profit for each outcome
        for i, (outcome, stake, return_amt) in enumerate(zip(outcomes, stakes, returns)):
            other_stakes_total = sum(s for j, s in enumerate(stakes) if j != i)
            net_profit = return_amt - total_stake
            
            message += f"""
<b>IF {outcome.upper()} WINS:</b>
{bookmakers_dict.get(outcome, 'Unknown').upper()} pays: ${return_amt:.2f}
Other bets lose: -${other_stakes_total:.2f}
<b>Net Profit: ${net_profit:.2f}</b> âœ…

"""
        
        message += f"""
ğŸ‰ <b>YOU WIN EITHER WAY!</b> ğŸ‰

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ <b>URGENT - PLACE BETS NOW!</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â±ï¸ These odds can change in SECONDS
âœ… Both bookmakers are reliable
ğŸ’° {(profit/total_stake*100):.2f}% return guaranteed
ğŸ”’ Risk-free profit

âš ï¸ <b>Tips:</b>
â€¢ Place both bets within 1-2 minutes
â€¢ Double-check odds before confirming
â€¢ Screenshot both bet slips
â€¢ Have accounts pre-funded

ğŸš€ <b>GO GO GO!</b>

"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error formatting arbitrage notification: {e}", exc_info=True)
        # Send simplified fallback message
        fallback = f"""
ğŸ’° <b>ARBITRAGE ALERT!</b>

Match: {arb.get('home_team', 'N/A')} vs {arb.get('away_team', 'N/A')}
Profit: ${profit:.2f}

Check bot for details!
"""
        return send_telegram_message(fallback)


# === BET PLACEMENT NOTIFICATIONS ===

def send_bet_placed_alert(
    bet_details: Dict[str, Any],
    bet_number: int,
    total_bets: int,
    arb_id: Optional[str] = None,
    is_simulation: bool = True
) -> bool:
    """
    Send detailed notification when individual bet is placed (Option B).
    
    Args:
        bet_details: Dictionary containing bet information
        bet_number: Current bet number (1, 2, etc.)
        total_bets: Total number of bets in this arbitrage
        arb_id: Arbitrage opportunity ID
        is_simulation: Whether this is a demo/simulation bet
        
    Returns:
        True if sent successfully
    """
    try:
        mode_indicator = "ğŸ”´ DEMO MODE" if is_simulation else "ğŸŸ¢ LIVE"
        
        bookmaker = bet_details.get('bookmaker', 'Unknown').upper()
        selection = bet_details.get('selection', 'Unknown')
        stake = bet_details.get('stake', 0)
        odds = bet_details.get('odds', 0)
        sport = bet_details.get('sport', 'Unknown').replace('_', ' ').title()
        home_team = bet_details.get('home_team', 'Team A')
        away_team = bet_details.get('away_team', 'Team B')
        game_time = bet_details.get('game_time', '')
        
        american_odds = decimal_to_american(odds)
        potential_return = stake * odds
        potential_profit = potential_return - stake
        readable_time = format_readable_time(game_time) if game_time else "TBD"
        timestamp = datetime.now().strftime('%B %d, %I:%M:%S %p')
        
        # Calculate what's next
        remaining_bets = total_bets - bet_number
        next_bet_info = bet_details.get('next_bet', {})
        
        message = f"""
âœ… <b>BET SUCCESSFULLY PLACED</b>
{mode_indicator}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ <b>BET DETAILS</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ€ <b>Sport:</b> {sport}
ğŸŸï¸ <b>Match:</b> {home_team} vs {away_team}
â° <b>Game Time:</b> {readable_time}

ğŸ“ <b>Bookmaker:</b> {bookmaker}
ğŸ¯ <b>Selection:</b> {selection}
ğŸ’µ <b>Stake:</b> ${stake:.2f}
ğŸ“Š <b>Odds:</b> {odds:.2f} (American: {american_odds})
ğŸ’° <b>Potential Return:</b> ${potential_return:.2f}
ğŸ’¸ <b>Potential Profit:</b> ${potential_profit:.2f}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š <b>ARBITRAGE PROGRESS</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… Bet {bet_number} of {total_bets} placed
"""
        
        if remaining_bets > 0 and next_bet_info:
            next_bookmaker = next_bet_info.get('bookmaker', 'Unknown').upper()
            next_selection = next_bet_info.get('selection', 'Unknown')
            next_stake = next_bet_info.get('stake', 0)
            
            message += f"""
â³ <b>Next:</b> Bet ${next_stake:.2f} on {next_selection} @ {next_bookmaker}
"""
        else:
            guaranteed_profit = bet_details.get('guaranteed_profit', 0)
            message += f"""
ğŸ‰ <b>All bets for this arbitrage placed!</b>
ğŸ”’ <b>Guaranteed Profit:</b> ${guaranteed_profit:.2f}
"""
        
        message += f"""

â±ï¸ <b>Time:</b> {timestamp}
"""
        
        if arb_id:
            message += f"ğŸ†” <b>Arb ID:</b> {arb_id}\n"
        
        if is_simulation:
            message += """
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ <b>SIMULATION MODE</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

This is a TEST bet - no real money used.
Bet logged for demo analysis.

ğŸ’¡ To enable live betting:
Set SIMULATE_BET_PLACEMENT=0 in .env
"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error sending bet placed alert: {e}", exc_info=True)
        return False


def send_arbitrage_complete_alert(
    arb_summary: Dict[str, Any],
    is_simulation: bool = True
) -> bool:
    """
    Send completion notification when all bets in arbitrage are placed (Option C).
    
    Args:
        arb_summary: Dictionary containing complete arbitrage summary
        is_simulation: Whether this is a demo/simulation
        
    Returns:
        True if sent successfully
    """
    try:
        mode_indicator = "ğŸ”´ DEMO" if is_simulation else "ğŸŸ¢ LIVE"
        
        home_team = arb_summary.get('home_team', 'Team A')
        away_team = arb_summary.get('away_team', 'Team B')
        sport = arb_summary.get('sport', 'Unknown').replace('_', ' ').title()
        game_time = arb_summary.get('game_time', '')
        bets = arb_summary.get('bets', [])
        total_stake = arb_summary.get('total_stake', 0)
        guaranteed_return = arb_summary.get('guaranteed_return', 0)
        guaranteed_profit = arb_summary.get('guaranteed_profit', 0)
        roi = arb_summary.get('roi', 0)
        
        readable_time = format_readable_time(game_time) if game_time else "TBD"
        
        message = f"""
ğŸ‰ <b>ARBITRAGE COMPLETE!</b> {mode_indicator}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… <b>ALL BETS SUCCESSFULLY PLACED</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ€ <b>{sport}</b>
ğŸŸï¸ {home_team} vs {away_team}
â° {readable_time}

"""
        
        # List all bets
        for i, bet in enumerate(bets, 1):
            bookmaker = bet.get('bookmaker', 'Unknown').upper()
            selection = bet.get('selection', 'Unknown')
            stake = bet.get('stake', 0)
            odds = bet.get('odds', 0)
            
            message += f"""
<b>BET {i}:</b> âœ… CONFIRMED
ğŸ“ {bookmaker}
ğŸ¯ {selection}
ğŸ’µ Stake: ${stake:.2f} @ {odds:.2f}

"""
        
        message += f"""
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’° <b>GUARANTEED RESULTS</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š <b>Total Invested:</b> ${total_stake:.2f}
ğŸ’µ <b>Guaranteed Return:</b> ${guaranteed_return:.2f}
âœ¨ <b>Guaranteed Profit:</b> ${guaranteed_profit:.2f}
ğŸ“ˆ <b>ROI:</b> {roi:.2f}%

ğŸ‰ <b>YOU CAN'T LOSE!</b>

Regardless of which team wins, you profit ${guaranteed_profit:.2f}

â° <b>Game Time:</b> {readable_time}
ğŸ“± Track both bets in your bookmaker apps
"""
        
        if is_simulation:
            message += """

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”´ <b>DEMO MODE</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

This was a simulated arbitrage.
All bets logged for analysis.

ğŸ“Š Check dashboard for performance
"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error sending arbitrage complete alert: {e}", exc_info=True)
        return False


def send_bet_failed_alert(
    bet_details: Dict[str, Any],
    reason: str,
    bet_number: int,
    total_bets: int
) -> bool:
    """
    Send notification when bet placement fails.
    
    Args:
        bet_details: Dictionary containing bet information
        reason: Failure reason
        bet_number: Current bet number
        total_bets: Total number of bets in this arbitrage
        
    Returns:
        True if sent successfully
    """
    try:
        bookmaker = bet_details.get('bookmaker', 'Unknown').upper()
        selection = bet_details.get('selection', 'Unknown')
        stake = bet_details.get('stake', 0)
        home_team = bet_details.get('home_team', 'Team A')
        away_team = bet_details.get('away_team', 'Team B')
        
        completed_bets = bet_number - 1
        
        message = f"""
âŒ <b>BET PLACEMENT FAILED</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ <b>ISSUE WITH BET</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸŸï¸ <b>Match:</b> {home_team} vs {away_team}
ğŸ“ <b>Bookmaker:</b> {bookmaker}
ğŸ¯ <b>Selection:</b> {selection}
ğŸ’µ <b>Attempted Stake:</b> ${stake:.2f}

ğŸ“ <b>Reason:</b> {reason}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ <b>ACTION REQUIRED</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ”´ <b>ARBITRAGE INCOMPLETE</b>
Only {completed_bets} of {total_bets} bets placed
"""
        
        if completed_bets > 0:
            message += """

âš ï¸ <b>You may have EXPOSURE RISK if you place the other bet</b>
"""
        
        message += f"""

ğŸ’¡ <b>Next Steps:</b>
1. Resolve issue with {bookmaker}
2. Retry this arbitrage opportunity
3. OR skip this opportunity

â° <b>Odds may change - act quickly!</b>
"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error sending bet failed alert: {e}", exc_info=True)
        return False


# === ERROR ALERTS ===

def send_error_alert(error_type: str, error_msg: str, severity: str = "warning") -> bool:
    """
    Send user-friendly error notification.
    
    Args:
        error_type: Type of error (API, Network, etc)
        error_msg: Error message
        severity: warning, error, critical
    """
    emoji_map = {
        'warning': 'âš ï¸',
        'error': 'âŒ',
        'critical': 'ğŸš¨'
    }
    
    emoji = emoji_map.get(severity, 'âš ï¸')
    
    message = f"""
{emoji} *{severity.upper()}: {error_type}*

ğŸ“ <b>Issue:</b> {error_msg}

"""
    
    if severity == "critical":
        message += """
ğŸš¨ <b>IMMEDIATE ACTION REQUIRED</b>
Please check bot immediately!
Bot may have stopped functioning
"""
    elif severity == "error":
        message += """
âš ï¸ <b>Bot may need attention</b>
Check logs for details.
Monitoring may be affected.
"""
    else:
        message += """
â„¹ï¸ <b>Minor issue - bot continuing</b>
No action required.
This is informational only.
"""
    
    return send_telegram_message(message)


# === SYSTEM STATUS ===

def send_startup_notification(version: str, config: Dict[str, Any]) -> bool:
    """Notify that bot has started."""
    message = f"""

ğŸ¤‘ <b>ARBITRAGE BOT STARTED</b>

ğŸ“Š <b>Version:</b> {version}

âš™ï¸ <b>Mode:</b> {'ğŸ§ª SIMULATION' if config.get('simulate', True) else 'ğŸ¯ LIVE TRADING'}

ğŸ’° <b>Bankroll:</b> ${config.get('bankroll', 0):.2f}

ğŸ“ˆ <b>Min Margin:</b> {config.get('min_margin', 0)*100:.2f}%


âš¡ <b>Sports Monitored:</b>

{', '.join(config.get('sports', []))}

ğŸ“Š <b>Markets:</b>

{', '.join(config.get('markets', []))}


âœ… <b>Bot is now monitoring for opportunities!</b>

ğŸ“² You'll receive alerts when arbitrage is detected.
"""
    
    return send_telegram_message(message)


def send_shutdown_notification(reason: str = "Normal shutdown", stats: Dict[str, Any] = None) -> bool:
    """Notify that bot has stopped."""
    message = f"""
ğŸ›‘ <b>ARBITRAGE BOT STOPPED</b>

Reason: {reason}
Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

"""
    
    if stats:
        message += f"""
ğŸ“Š <b>Session Summary:</b>
â€¢ Opportunities Found: {stats.get('opportunities', 0)}
â€¢ Total Profit: ${stats.get('total_profit', 0):.2f}
â€¢ Runtime: {stats.get('uptime', 'N/A')}
"""
    
    message += """
â„¹ï¸ <b>Bot has stopped monitoring.</b>
Restart required to resume operations.
"""
    
    return send_telegram_message(message)


# === PERFORMANCE REPORTS ===

def send_daily_report(metrics: Dict[str, Any]) -> bool:
    """Send clear daily performance summary."""
    profit = metrics.get('total_profit', 0)
    profit_emoji = "ğŸŸ¢" if profit > 0 else "ğŸ”´" if profit < 0 else "âšª"
    
    message = f"""
ğŸ“Š <b>DAILY PERFORMANCE REPORT</b>
{datetime.now().strftime('%B %d, %Y')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’° <b>PROFIT/LOSS:</b> {profit_emoji} ${profit:.2f}

ğŸ“ˆ <b>TRADING STATS:</b>
â€¢ Total Bets: {metrics.get('total_bets', 0)}
â€¢ Wins: {metrics.get('wins', 0)} âœ…
â€¢ Losses: {metrics.get('losses', 0)} âŒ
â€¢ Win Rate: {metrics.get('win_rate', 0)*100:.1f}%

ğŸ“Š <b>PERFORMANCE:</b>
â€¢ Avg Profit/Bet: ${metrics.get('avg_profit', 0):.2f}
â€¢ Best Bet: ${metrics.get('best_bet', 0):.2f}
â€¢ Worst Bet: ${metrics.get('worst_bet', 0):.2f}

ğŸ’¼ <b>BANKROLL:</b>
â€¢ Starting: ${metrics.get('start_bankroll', 0):.2f}
â€¢ Current: ${metrics.get('current_bankroll', 0):.2f}
â€¢ ROI: {metrics.get('roi', 0):.2f}%

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    
    if profit > 0:
        message += "ğŸ‰ <b>Excellent trading day!</b>"
    elif profit < 0:
        message += "ğŸ“‰ <b>Review and adjust strategy</b>"
    else:
        message += "âš–ï¸ <b>Break-even day</b>"
    
    return send_telegram_message(message)
def send_daily_report(metrics: Dict[str, Any]) -> bool:
    """Send clear daily performance summary."""
    profit = metrics.get('total_profit', 0)
    profit_emoji = "ğŸŸ¢" if profit > 0 else "ğŸ”´" if profit < 0 else "âšª"
    
    message = f"""
ğŸ“Š <b>DAILY PERFORMANCE REPORT</b>
{datetime.now().strftime('%B %d, %Y')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’° <b>PROFIT/LOSS:</b> {profit_emoji} ${profit:.2f}

ğŸ“ˆ <b>TRADING STATS:</b>
â€¢ Total Bets: {metrics.get('total_bets', 0)}
â€¢ Wins: {metrics.get('wins', 0)} âœ…
â€¢ Losses: {metrics.get('losses', 0)} âŒ
â€¢ Win Rate: {metrics.get('win_rate', 0)*100:.1f}%

ğŸ“Š <b>PERFORMANCE:</b>
â€¢ Avg Profit/Bet: ${metrics.get('avg_profit', 0):.2f}
â€¢ Best Bet: ${metrics.get('best_bet', 0):.2f}
â€¢ Worst Bet: ${metrics.get('worst_bet', 0):.2f}

ğŸ’¼ <b>BANKROLL:</b>
â€¢ Starting: ${metrics.get('start_bankroll', 0):.2f}
â€¢ Current: ${metrics.get('current_bankroll', 0):.2f}
â€¢ ROI: {metrics.get('roi', 0):.2f}%

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    
    if profit > 0:
        message += "ğŸ‰ <b>Excellent trading day!</b>"
    elif profit < 0:
        message += "ğŸ“‰ <b>Review and adjust strategy</b>"
    else:
        message += "âš–ï¸ <b>Break-even day</b>"
    
    return send_telegram_message(message)

# === BACKUP NOTIFICATIONS ===

def send_backup_notification(
    backup_path: str,
    backup_type: str,
    backup_size_mb: float,
    checksum: str = None,
    is_success: bool = True
) -> bool:
    """
    Send backup creation notification to Telegram.
    
    Args:
        backup_path: Path to backup file
        backup_type: Type of backup (startup, shutdown, daily, manual)
        backup_size_mb: Size of backup in MB
        checksum: SHA256 checksum
        is_success: Whether backup was successful
        
    Returns:
        True if sent successfully
    """
    try:
        if is_success:
            emoji = "âœ…"
            status = "SUCCESSFUL"
        else:
            emoji = "âŒ"
            status = "FAILED"
        
        message = f"""
{emoji} *BACKUP {status}*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”„ <b>Backup Type:</b> {backup_type.upper()}
ğŸ“ <b>File:</b> <code>{os.path.basename(backup_path)}</code>
ğŸ’¾ <b>Size:</b> {backup_size_mb:.2f} MB
â° <b>Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        if checksum and len(checksum) > 0:
            message += f"ğŸ” <b>Checksum:</b> <code>{checksum[:16]}...</code>\n"
        
        message += """
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
        
        if is_success:
            message += """
âœ… Backup stored and ready for recovery
ğŸ“Š Use dashboard for restore options
"""
        else:
            message += """
âš ï¸ Please check logs for error details
ğŸ”§ Retry manually or contact support
"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error sending backup notification: {e}", exc_info=True)
        return False


def send_backup_cleanup_notification(
    stats: dict
) -> bool:
    """
    Send backup cleanup notification to Telegram.
    
    Args:
        stats: Cleanup statistics dictionary
        
    Returns:
        True if sent successfully
    """
    try:
        message = f"""
ğŸ§¹ <b>BACKUP CLEANUP COMPLETE</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š <b>Cleanup Statistics:</b>

Backups before: {stats.get('total_before', 0)}
Backups deleted: {stats.get('deleted', 0)}
Backups kept: {stats.get('total_before', 0) - stats.get('deleted', 0)}

âœ… Recent (7d): {stats.get('kept_recent', 0)}
ğŸ“Š Medium (30d): {stats.get('kept_medium', 0)}
ğŸ“ˆ Archive (90d): {stats.get('kept_archive', 0)}

ğŸ’¾ Space freed: {stats.get('freed_mb', 0):.2f} MB
â° Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Storage optimized and ready
"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error sending cleanup notification: {e}", exc_info=True)
        return False


def send_backup_restore_notification(
    backup_path: str,
    is_success: bool = True,
    error_msg: str = None
) -> bool:
    """
    Send backup restore notification to Telegram.
    
    Args:
        backup_path: Path to restored backup
        is_success: Whether restore was successful
        error_msg: Error message if failed
        
    Returns:
        True if sent successfully
    """
    try:
        if is_success:
            message = f"""
âœ… <b>BACKUP RESTORE SUCCESSFUL</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ <b>Backup:</b> {os.path.basename(backup_path)}
â° <b>Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… All files restored successfully
ğŸ”„ Please restart bot to apply changes
"""
        else:
            message = f"""
âŒ <b>BACKUP RESTORE FAILED</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ <b>Backup:</b> {os.path.basename(backup_path)}
ğŸ“ <b>Error:</b> {error_msg or 'Unknown error'}
â° <b>Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš ï¸ Restore failed - check logs for details
"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error sending restore notification: {e}", exc_info=True)
        return False


def send_backup_status_report(
    stats: dict
) -> bool:
    """
    Send backup status report to Telegram.
    
    Args:
        stats: Backup statistics dictionary
        
    Returns:
        True if sent successfully
    """
    try:
        total_backups = stats.get('total_backups', 0)
        total_size_gb = stats.get('total_size_gb', 0)
        by_type = stats.get('by_type', {})
        
        message = f"""
ğŸ“Š <b>BACKUP STATUS REPORT</b>

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ˆ <b>Overview:</b>
â€¢ Total Backups: {total_backups}
â€¢ Total Storage: {total_size_gb} GB
â€¢ Oldest: {stats.get('oldest_backup', 'N/A')}
â€¢ Newest: {stats.get('newest_backup', 'N/A')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ <b>By Type:</b>
"""
        
        for backup_type, data in by_type.items():
            message += f"Ã¢â‚¬Â¢ {backup_type.title()}: {data['count']} backups ({data['size_mb']:.1f} MB)\n"
        
        message += f"""
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â° Report Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

âœ… Backup system is healthy and operational
"""
        
        return send_telegram_message(message)
        
    except Exception as e:
        logger.error(f"Error sending status report: {e}", exc_info=True)
        return False
